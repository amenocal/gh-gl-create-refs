package cmd

import (
	"fmt"
	"path/filepath"

	"github.com/amenocal/gh-gl-create-refs/pkg/csv"
	"github.com/amenocal/gh-gl-create-refs/pkg/gitlab"
	"github.com/spf13/cobra"
)

var createRefsCmd = &cobra.Command{
	Use:   "create-refs",
	Short: "Create GitLab branches from merge request references",
	Long: `Create GitLab branches based on merge request references from a CSV file or by fetching them in real-time.

This command reads merge request references (either from a CSV file generated by fetch-refs or by fetching directly) 
and creates branches in the specified repository using the naming pattern 'migration-pr-<PRNumber>'.
If no target repository is specified, branches will be created in the source repository.

The CSV file should contain two columns:
1. Merge request number (IID)
2. Head SHA from diff_refs

Examples:
  gh gl-create-refs create-refs --input group-project.csv --repository group/project
  gh gl-create-refs create-refs -i refs.csv -r group/project --target target-group/target-project --token your_token
  gh gl-create-refs create-refs --repository source-group/source-project --fetch
  gh gl-create-refs create-refs -r source/repo --target target/repo --fetch --base-url https://gitlab.example.com`,
	Args: cobra.NoArgs,
	RunE: runCreateRefs,
}

var (
	createInputFile  string
	createRepository string
	createTargetRepo string
	token            string
	baseURL          string
	createFetch      bool
)

// generateBranchName creates a branch name following the migration pattern
func generateBranchName(prNumber int) string {
	return fmt.Sprintf("migration-pr-%d", prNumber)
}

func init() {
	rootCmd.AddCommand(createRefsCmd)

	createRefsCmd.Flags().StringVarP(&createInputFile, "input", "i", "", "Input CSV file path (required unless --fetch is used)")
	createRefsCmd.Flags().StringVarP(&createRepository, "repository", "r", "", "Source GitLab repository path (required)")
	createRefsCmd.Flags().StringVarP(&createTargetRepo, "target", "", "", "Target GitLab repository path where branches will be created (optional, defaults to repository)")
	createRefsCmd.Flags().StringVarP(&token, "token", "t", "", "GitLab access token (can also use GITLAB_TOKEN environment variable)")
	createRefsCmd.Flags().StringVarP(&baseURL, "base-url", "b", "", "GitLab base URL (default: https://gitlab.com)")
	createRefsCmd.Flags().BoolVar(&createFetch, "fetch", false, "Fetch merge requests in real-time instead of using CSV file")

	// Mark the repository flag as required
	createRefsCmd.MarkFlagRequired("repository")
}

func runCreateRefs(cmd *cobra.Command, args []string) error {
	// Validate input parameters
	if err := validateCreateRefsFlags(); err != nil {
		return err
	}

	// Create GitLab client from flags and environment
	client, err := gitlab.NewClient(token, baseURL)
	if err != nil {
		return err
	}

	// Get merge request references
	refs, err := getMergeRequestRefs(client)
	if err != nil {
		return err
	}

	if len(refs) == 0 {
		fmt.Printf("No merge request references found to process\n")
		return nil
	}

	// Determine target repository
	targetRepo := createTargetRepo
	if targetRepo == "" {
		targetRepo = createRepository
	}

	// Create branches in target repository
	return createBranchesInRepo(client, refs, targetRepo)
}

func validateCreateRefsFlags() error {
	if createRepository == "" {
		return fmt.Errorf("--repository is required")
	}

	if !createFetch && createInputFile == "" {
		return fmt.Errorf("--input is required unless --fetch is used")
	}

	return nil
}

func getMergeRequestRefs(client *gitlab.Client) ([]gitlab.MergeRequestRef, error) {
	if createFetch {
		return fetchMergeRequestRefsRealTime(client)
	}
	return readMergeRequestRefsFromCSV()
}

func fetchMergeRequestRefsRealTime(client *gitlab.Client) ([]gitlab.MergeRequestRef, error) {
	fmt.Printf("Fetching merge requests from %s...\n", createRepository)
	
	var fetchedRefs []gitlab.MergeRequestRef
	processor := func(ref gitlab.MergeRequestRef) error {
		fetchedRefs = append(fetchedRefs, ref)
		return nil
	}

	_, err := client.FetchMergeRequestRefsFromRepo(createRepository, baseURL, processor)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch merge requests: %w", err)
	}
	
	fmt.Printf("Found %d merge requests\n", len(fetchedRefs))
	return fetchedRefs, nil
}

func readMergeRequestRefsFromCSV() ([]gitlab.MergeRequestRef, error) {
	fmt.Printf("Reading merge request references from %s...\n", createInputFile)
	
	refs, err := csv.ReadRefsFromFile(createInputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read CSV file: %w", err)
	}
	
	fmt.Printf("Found %d merge request references in CSV file\n", len(refs))
	return refs, nil
}

func createBranchesInRepo(client *gitlab.Client, refs []gitlab.MergeRequestRef, targetRepo string) error {
	// Parse target repository path
	_, targetProjectPath, err := gitlab.ParseRepoPath(targetRepo)
	if err != nil {
		return fmt.Errorf("failed to parse target repository path: %w", err)
	}

	fmt.Printf("Creating branches in %s...\n", targetProjectPath)

	// Create branches
	successCount := 0
	errorCount := 0

	for _, ref := range refs {
		branchName := generateBranchName(ref.IID)
		
		fmt.Printf("Creating branch '%s' from SHA %s...", branchName, ref.HeadSHA)
		
		err = client.CreateBranch(targetProjectPath, branchName, ref.HeadSHA)
		if err != nil {
			fmt.Printf(" âŒ Failed: %v\n", err)
			errorCount++
		} else {
			fmt.Printf(" âœ… Created successfully\n")
			successCount++
		}
	}

	printSummary(successCount, errorCount, len(refs))
	return nil
}

func printSummary(successCount, errorCount, totalCount int) {
	fmt.Printf("\nSummary:\n")
	fmt.Printf("âœ… Successfully created: %d branches\n", successCount)
	if errorCount > 0 {
		fmt.Printf("âŒ Failed: %d branches\n", errorCount)
	}
	fmt.Printf("ğŸ“‹ Total processed: %d merge requests\n", totalCount)

	// Get absolute path for the input file if used
	if !createFetch && createInputFile != "" {
		absPath, err := filepath.Abs(createInputFile)
		if err != nil {
			absPath = createInputFile // Fallback to relative path
		}
		fmt.Printf("ğŸ“„ Input file: %s\n", absPath)
	}
}