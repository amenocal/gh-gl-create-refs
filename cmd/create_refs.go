package cmd

import (
	"fmt"
	"path/filepath"

	"github.com/amenocal/gh-gl-create-refs/pkg/csv"
	"github.com/amenocal/gh-gl-create-refs/pkg/gitlab"
	"github.com/spf13/cobra"
)

var createRefsCmd = &cobra.Command{
	Use:   "create-refs",
	Short: "Create GitLab branches from merge request references",
	Long: `Create GitLab branches based on merge request references from a CSV file or by fetching them in real-time.

This command reads merge request references (either from a CSV file generated by fetch-refs or by fetching directly) 
and creates branches in the specified repository using the naming pattern 'migration-pr-<PRNumber>'.
If no target repository is specified, branches will be created in the source repository.

The CSV file should contain two columns:
1. Merge request number (IID)
2. Head SHA from diff_refs

Examples:
  gh gl-create-refs create-refs --input group-project.csv --repository group/project
  gh gl-create-refs create-refs -i refs.csv -r group/project --target target-group/target-project --token your_token
  gh gl-create-refs create-refs --repository source-group/source-project --fetch
  gh gl-create-refs create-refs -r source/repo --target target/repo --fetch --base-url https://gitlab.example.com
  gh gl-create-refs create-refs --repository source/repo --fetch --mock`,
	Args: cobra.NoArgs,
	RunE: runCreateRefs,
}

// No global variables needed - using local variables with flag access

// generateBranchName creates a branch name following the migration pattern
func generateBranchName(prNumber int) string {
	return fmt.Sprintf("migration-pr-%d", prNumber)
}

func init() {
	rootCmd.AddCommand(createRefsCmd)

	createRefsCmd.Flags().StringP("input", "i", "", "Input CSV file path (required unless --fetch is used)")
	createRefsCmd.Flags().StringP("repository", "r", "", "Source GitLab repository path (required)")
	createRefsCmd.Flags().String("target", "", "Target GitLab repository path where branches will be created (optional, defaults to repository)")
	createRefsCmd.Flags().StringP("token", "t", "", "GitLab access token (can also use GITLAB_TOKEN environment variable)")
	createRefsCmd.Flags().StringP("base-url", "b", "", "GitLab base URL (default: https://gitlab.com)")
	createRefsCmd.Flags().Bool("fetch", false, "Fetch merge requests in real-time instead of using CSV file")
	createRefsCmd.Flags().Bool("mock", false, "Mock mode: simulate branch creation without actually creating branches")

	// Mark the repository flag as required
	createRefsCmd.MarkFlagRequired("repository")
}

func runCreateRefs(cmd *cobra.Command, args []string) error {
	// Get parameters from flags
	inputFile := cmd.Flag("input").Value.String()
	repository := cmd.Flag("repository").Value.String()
	targetRepository := cmd.Flag("target").Value.String()
	token := cmd.Flag("token").Value.String()
	baseURL := cmd.Flag("base-url").Value.String()
	fetch, _ := cmd.Flags().GetBool("fetch")
	mock, _ := cmd.Flags().GetBool("mock")

	// Validate input parameters
	if err := validateCreateRefsFlags(repository, fetch, inputFile); err != nil {
		return err
	}

	// Create GitLab client from flags and environment
	client, err := gitlab.NewClient(token, baseURL)
	if err != nil {
		return err
	}

	// Get merge request references
	refs, err := getMergeRequestRefs(client, fetch, inputFile, repository, baseURL)
	if err != nil {
		return err
	}

	if len(refs) == 0 {
		fmt.Printf("No merge request references found to process\n")
		return nil
	}

	// Determine target repository
	targetRepo := targetRepository
	if targetRepo == "" {
		targetRepo = repository
	}

	// Create branches in target repository
	return createBranchesInRepo(client, refs, targetRepo, fetch, inputFile, mock)
}

func validateCreateRefsFlags(repository string, fetch bool, inputFile string) error {
	if repository == "" {
		return fmt.Errorf("--repository is required")
	}

	if !fetch && inputFile == "" {
		return fmt.Errorf("--input is required unless --fetch is used")
	}

	return nil
}

func getMergeRequestRefs(client *gitlab.Client, fetch bool, inputFile, repository, baseURL string) ([]gitlab.MergeRequestRef, error) {
	if fetch {
		return fetchMergeRequestRefsRealTime(client, repository, baseURL)
	}
	return readMergeRequestRefsFromCSV(inputFile)
}

func fetchMergeRequestRefsRealTime(client *gitlab.Client, repository, baseURL string) ([]gitlab.MergeRequestRef, error) {
	fmt.Printf("Fetching merge requests from %s...\n", repository)

	var fetchedRefs []gitlab.MergeRequestRef
	processor := func(ref gitlab.MergeRequestRef) error {
		fetchedRefs = append(fetchedRefs, ref)
		return nil
	}

	_, err := client.FetchMergeRequestRefsFromRepo(repository, baseURL, processor)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch merge requests: %w", err)
	}

	fmt.Printf("Found %d merge requests\n", len(fetchedRefs))
	return fetchedRefs, nil
}

func readMergeRequestRefsFromCSV(inputFile string) ([]gitlab.MergeRequestRef, error) {
	fmt.Printf("Reading merge request references from %s...\n", inputFile)

	refs, err := csv.ReadRefsFromFile(inputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read CSV file: %w", err)
	}

	fmt.Printf("Found %d merge request references in CSV file\n", len(refs))
	return refs, nil
}

func createBranchesInRepo(client *gitlab.Client, refs []gitlab.MergeRequestRef, targetRepo string, fetch bool, inputFile string, mock bool) error {
	// Parse target repository path
	_, targetProjectPath, err := gitlab.ParseRepoPath(targetRepo)
	if err != nil {
		return fmt.Errorf("failed to parse target repository path: %w", err)
	}

	if mock {
		fmt.Printf("🧪 Mock mode: Simulating branch creation in %s...\n", targetProjectPath)
	} else {
		fmt.Printf("Creating branches in %s...\n", targetProjectPath)
	}

	// Create branches
	successCount := 0
	errorCount := 0

	for _, ref := range refs {
		branchName := generateBranchName(ref.IID)

		if mock {
			// Mock mode: just print what would be created
			fmt.Printf("Created branch %s with sha: %s\n", branchName, ref.HeadSHA)
			successCount++
		} else {
			// Real mode: actually create the branch
			fmt.Printf("Creating branch '%s' from SHA %s...", branchName, ref.HeadSHA)

			err = client.CreateBranch(targetProjectPath, branchName, ref.HeadSHA)
			if err != nil {
				fmt.Printf(" ❌ Failed: %v\n", err)
				errorCount++
			} else {
				fmt.Printf(" ✅ Created successfully\n")
				successCount++
			}
		}
	}

	printSummary(successCount, errorCount, len(refs), fetch, inputFile)
	return nil
}

func printSummary(successCount, errorCount, totalCount int, fetch bool, inputFile string) {
	fmt.Printf("\nSummary:\n")
	fmt.Printf("✅ Successfully created: %d branches\n", successCount)
	if errorCount > 0 {
		fmt.Printf("❌ Failed: %d branches\n", errorCount)
	}
	fmt.Printf("📋 Total processed: %d merge requests\n", totalCount)

	// Get absolute path for the input file if used
	if !fetch && inputFile != "" {
		absPath, err := filepath.Abs(inputFile)
		if err != nil {
			absPath = inputFile // Fallback to relative path
		}
		fmt.Printf("📄 Input file: %s\n", absPath)
	}
}
